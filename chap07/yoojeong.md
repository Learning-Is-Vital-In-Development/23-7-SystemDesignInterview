## 7장: 처리율 제한 장치의 설계

유일 ID로 관계형 데이터베이스의 auto_increment 를 쓸수는 없을까?

- 분산 환경에서는 데이터베이스 서버 한대로 감당하기 어려움
- 여러 데이터베이스 서버를 쓰는 경우 지연 시간을 낮추기 힘듦 (쓰기 동기화)

### 문제 이해 및 설계 범위 확정

```
- ID는 유일해야 한다.
- ID는 숫자로만 구성되어야 한다.
- ID는 64비트로 표현될 수 있는 값이어야 한다.
- ID는 발급 날짜에 따라 정렬 가능해야 한다.
- 초당 10,000개의 ID를 만들 수 있어야 한다.
```

### 개략적인 설계안 제시 및 동의 구하기

---

#### 다중 마스터 복제

<img width="367" alt="image" src="https://user-images.githubusercontent.com/75432228/235428405-38019125-c933-4e32-ac11-a1762007bb2d.png">

auto-increment 를 사용하나, 1씩 증가가 아닌 k(서버의 수)씩 증가

Q. 이 내용은 이전 안정 해시때도 서버가 늘어나면 바로 문제가 생기는 로직이었는데...?

| 장점                                                                                                  | 단점                                                                                                                                                                                                                                       |
| :---------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| DBMS 인스턴스 수에 따라 초당 생산 가능한 ID 수를 늘릴 수 있음<br>별도의 과정 없이 ID를 사용할 수 있다 | 여러 데이터 센터에 걸쳐 규모를 늘리기 어려움<br>ID의 유일성은 보장되지만 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없음<br>서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다<br>ORM의 경우 Destination 설정이 필요할 수 있다 |

---

#### UUID(Universally Unique Identifier)

컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128 bit의 식별키, 충돌 가능성이 낮음

| 장점                                                                    | 단점                                                                                                                             |
| :---------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------- |
| 보장된 알고리즘<br>서버간 조율 없이 독립적으로 생성 가능(동기화 불필요) | ID 길이가 128비트로 길다.(요구사항은 64비트) <br>ID를 시간순으로 정렬할 수 없다<br>ID에 숫자(numeric)가 아닌 값이 포함될 수 있음 |

---

#### 티켓 서버(ticket server)

<img width="760" alt="image" src="https://user-images.githubusercontent.com/75432228/235428435-b22b9664-ad43-4c94-8604-e8bde40c515a.png">


- 플리커(Flickr)는 분산 기본 키를 만들어 내기 위해 이 기술을 이용
- AUTO INCREMENT 기능을 갖춘 데이터베이스 서버(티켓 서버)를 중앙 집중형으로 하나만 사용

| 장점                                                                                                    | 단점                                                                                                     |
| :------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------- |
| 유일성이 보장되는 숫자로만 구성된 ID를 쉽게 만들 수 있음<br>구현하기 쉽고 중소 규모 애플리케이션에 적합 | 티켓 서버가 SPOF<br>이 이슈를 피하기 위해 티켓 서버를 여러 대 준비하면 데이터 동기화 등 새로운 이슈 발생 |

---

#### 트위터 스노우 플레이크(twitter snowflake)

<img width="728" alt="image" src="https://user-images.githubusercontent.com/75432228/235428454-95ae7e3e-0bae-47c2-a214-eff1650ad0c4.png">


`S:T41:DC5:SI5:SEQ:12`

- 사인 비트(1 bit) : 음수 양수 구별, 나중을 위해 유보 (버퍼)
- 타임스탬프(41 bit) : epoch 이후 밀리초 경과했는지를 나타내는 값
- 데이터선터 ID(5 bit) : 2^5 = 32개의 데이터 센터 표현
- 서버 ID(5 bit) : 2^5 = 32개의 서버 표현
- 일련번호(12 bit) : 각 서버에서는 ID 생성시마다 해당 sequence 1씩 증가. 1 millisecond마다 0으로 초기화

> Mongo ObjectID 가 timestamp + machine identifier + process id + random counter 인데 비슷한거같다

---

### 상세 설계

- 데이터 센터 ID와 서버 ID는 시스템이 시작할때 결정되며 일반적으로 시스템 운영중에 바뀌지 않음
- 타임스탬프나 일련번호는 ID 생성기가 돌고 있는 중에 만들어짐

`타임스탬프`

<img width="723" alt="image" src="https://user-images.githubusercontent.com/75432228/235428479-e7ce5f67-6a7e-452f-9936-bd95d3c496d0.png">


- 가장 큰 41비트를 차지하고 있음
- 시간에 따라 점점 큰 값을 갖게 되므로 ID는 시간 순으로 정렬 가능
- 41비트로 표현할 수 있는 최댓값은 2^41-1 = 2199023255551ms = 약 69년으로, epoch 시간 기준 69년 후에는 ID 체계를 다른 것으로 migration 해야함

`일련번호`

- 2^12 = 4096개의 값을 가질 수 있음
- 같은 밀리초 내에 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 갖게 됨 (중복 방지)

### 마무리

`시계 동기화 (clock synchronization)`

위 예제는 전부 같은 시계를 사용한다는 가정하에 구현했으나, 하나의 서버가 여러 코어에 실행되는 경우 유효하지 않을 수 있다.

NTP(Network Time Protocol) : 인터넷을 통해 컴퓨터 시간을 최상위 동기 클럭원(Master Clock)에 동기화 시키는 프로토콜

- 네트워크 상에 분산된 시간 서버들로부터 클라이언트(호스트, 라우터 등)의 동기화
- 연관된 장비들의 시간을 인터넷상으로 동기화 하여 모든 장비의 시간을 동일하게 만들어 주는 통신
- 최소 0.001초 단위까지 동기화 가능 (UTC 기반)

https://guslabview.tistory.com/452

[AWS time sync](https://aws.amazon.com/ko/blogs/mt/manage-amazon-ec2-instance-clock-accuracy-using-amazon-time-sync-service-and-amazon-cloudwatch-part-1/)

[AWS time sync2](https://aws.amazon.com/ko/blogs/mt/manage-amazon-ec2-instance-clock-accuracy-using-amazon-time-sync-service-and-amazon-cloudwatch-part-2/)

`컨테이너의 경우`

호스트 기반으로 시간 동기화 설정을 권장

```
/etc/localtime:/etc/localtome:ro
```

`Fargate같은 PaaS 컴퓨팅은?`

- 서비스 특성상 우리가 조작할 수 없음
- 가까운 위치에서 HOST VM을 기준으로 동기화 되고 있기때문에 그냥 사용해도 무방
- fireCracker = [AWS VM](https://aws.amazon.com/ko/blogs/korea/firecracker-lightweight-virtualization-for-serverless-computing/)

`각 절(section)의 길이 최적화`

- 동시성(concurrency)이 낮고 수명이 긴 애플리케이션이라면 일련번호의 길이를 줄이고 타임 스탬프절의 길이를 늘리는 것이 효과적일 수 있다

`고가용성(HA)`

- ID 생성기는 필수불가결(mission critical) 컴포넌트이므로 아주 높은 가용성을 제공해야 한다
