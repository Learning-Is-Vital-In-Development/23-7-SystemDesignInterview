# 12. 채팅 시스템 설계

# 문제 이해 및 설계 범위 확정

### 중요한 질문

1. 1대1 채팅앱 / 그룹 채팅 앱
2. 트래픽 규모
3. 중요 기능(ex. 텍스트 외에 다른 파일이나 이모지 등)
4. 메세지 길이의 제한
5. 종단 간 암호화 여부
6. 채팅 이력 보관

### 요구사항

- 응답지연이 낮은 1대1 채팅
- 최대 100명까지 참여할 수 있는 그룹 채팅 기능
- 사용자의 접속 상태 표시 기능
- 다양한 단말 지원. 하나의 계정으로 여러 단말에 동시 접속 지원
- 푸시 알림
- 5천만 DAU 처리

# 개략적인 설계안 제시 및 동의 구하기

## 제공하는 기능

- 클라이언트들로부터 메세지 수신
- 메세지 수신자(recipient) 결정 및 전달
- 수신자가 접속(online) 상태가 아닌 경우에는 접속할 때까지 해당 메세지 보관

## 통신 프로토콜

- 메세지 송신 클라이언트(sender)는 수신 클라이언트에게 전달할 메세지를 채팅 서비스에 보낼 때, 오랜 세월 검증된 HTTP 프로토콜을 사용
    - 채팅 서비스와 접속에는 keep-alive 헤더를 사용하면 연결을 끊지 않고 계속 유지할 수 있으며 tcp 접속에 사용되는 hand shake 횟수를 줄일 수 있다.
- 하지만 메세지 수신 시나리오는 이것과 다르게 복잡. HTTP는 서버에서 클라이언트로 임의 시점에 메세지를 보내는 데 사용하긴 어렵다.
- 이를 대신하기 위해서 폴링(polling), 롱 폴링(long polling), 웹소켓(web socket) 등이 제안되어 왔다.

### 폴링

- 클라이언트가 주기적으로 서버에세 새 메세지가 있는 지 물어보는 방식
- 자주할수록 서버 자원이 불필요하게 낭비된다는 문제가 존재

### 롱 폴링

- 클라이언트는 새 메세지가 반환되거나 타임아웃 될 떄가지 연결을 유지
- 새 메세지를 받으면 기존 연결을 종료하고 새로운 요청을 보내 모든 절차를 다시 시작
- 약점
    - 메세지를 보내는 클라이언트와 수신 하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수 있다.
    - 서버 입장에서는 클라이언트가 연결을 해제 했는 지 아닌 지 알 좋은 방법이 없다.
    - 여전히 비효율적이다.

### 웹소켓

- 웹소켓(WebSocket)은 서버가 클라이언트에게 비동기(async) 메세지를 보낼 때 가장 널리 사용되는 기술
- 웹소켓 연결은 클라이언트가 시작하고 한 번 맺어진 연결을 항구적이며 양방향이다.
- 처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 걸쳐 웹소켓 연결로 업그레이드 된다.

## 개략적인 설계안

채팅 시스템은 크게 세 부분으로 나누어 볼 수 있다.

- 무상태 서비스
- 상태 유지 서비스
- 제 3자 서비스 연동

### 무상태 서비스

- 로그인, 회원가입, 사용자 프로필 조회 등 전통적인 요청/응답 서비스

### 상태 유지 서비스

- 채팅 서비스, 각 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지해야 하기 때문

### 제 3자 서비스 연동

- 푸시 알림

### 규모의 확장성

![image](https://github.com/Learning-Is-Vital-In-Development/23-7-SystemDesignInterview/assets/61923768/7c385194-517c-4f6f-a8b7-a39fa53d8a44)

유의할 것은 실시간으로 메세지를 주고받기 위해 클라이언트는 채팅 서버와 웹소켓 연결을 끊지 않고 유지한든 것

- 채팅 서버는 클라이언트 사이에 메세지를 중계하는 역할
- 접속 상태 서버(presence server)는 사용자 접속 여부를 관리
- API 서버는 로그인, 회원가입, 프로파일 변경 등 그 외 나머지 전부를 처리
- 알림 서버는 푸시 알림을 보낸다.
- 키-값 저장소에는 채팅 이력(chat history)을 보관한다. 시스템에 접속한 사용자는 이전 채팅 이력을 전부 보게 될 것이다.

### 저장소

중요한 것 중 하나는 어떤 데이터베이스를 쓰느냐이고 이때 중요하게 고려해야 할 것은 `데이터 유형과 읽기/쓰기 연산의 패턴`

채팅 시스템에서 다루는 데이터는 크게 2가지

1. 사용자의 프로파일, 설정, 친구 목록과 같은 일반적인 데이터 → 관계형 데이터 베이스
2. 채팅 이력(chat history)
    1. 채팅 이력 데이터 양은 어마어마하다. 페이스북이나 왓츠앱은 매일 600억개 메세지를 처리한다.
    2. 가장 빈번하게 사용 되는 것은 최근의 주고 받은 메세지다. 대부분의 사용자는 오래된 메세지를 들여다보지 않는 다.
    3. 검색 기능을 이용하거나, 특정 사용자가 언급(mention)된 메시지를 보거나, 특정 메세지로 점프(jump)하거나 하여 무작위적인 데이터 접근을 하게 되는 일도 있다.
    4. 1:1 채팅 앱의 경우 읽기:쓰기 비율은 대략 1:1

채팅 이력 데이터의 저장소로 `키-값 저장소`를 추천하고 그 이유는 아래와 같다.

- 수평적 규모 확장(horizontal scaling)이 쉽다.
- 데이터 접근 지연시간(latency)이 낮다.
- RDB는 롱 테일에 해당하는 부분의 데이터를 잘 처리하지 못하는 경향이 있다. 인덱스가 커지면 무작위 접근을 처리하는 비용이 늘어난다.
- 이미 많은 안정적인 채팅 시스템이 키-값 저장소를 채택
  (facebook - HBase, discord - Cassandra)

## 데이터 모델

메시지 데이터를 어떻게 보관할 지 자세히 살펴보도록 하자.

### 1대1 채팅을 위한 메세지 테이블

| Message |  |
| --- | --- |
| message_id | bigint |
| message_form | bigint |
| message_to | bigint |
| content | text |
| created_at | timestamp |

기본키는 `mesage_id`이며 메세지의 순서를 쉽게 정할 수 있는 역할을 담당

### 그룹 채팅을 위한 메세지 테이블

| group message |  |
| --- | --- |
| channel_id | bigint |
| message_id | bigint |
| message_to | bigint |
| content | text |
| created_at | timestamp |

기본키는 `(channel_id, message_id)` 복합키를 기본 키로 사용.

channel은 채팅 그룹과 같은 뜻으로, partition key로도 사용할 것

### Message Id

message_id는 메세지들의 순서도 표현할 수 있어야 하기 때문에 다음의 속성을 만족해야 한다.

- message_id는 고유해야 한다.(Unique)
- ID 값은 정렬 가능해야 하며, 시간 순서와 일치해야 한다.

두 조건을 만족시키기 위해서는 RDBMS라면 `auto_increment`가 대안이 될 수 있겠지만, NoSQL은 보통 해당 기능을 지원하지 않는 다. 다른 대안으로는 `스노플레이크(SnowFlake)` 같은 전역 순서 번호 생성기를 이용하는 것이고 마지막 방법은 지역 순서 번호 생성기(local sequence number generator)를 이용하는 것이다. 여기서 지역이라는 것은 ID의 유일성은 그룹 내에서만 보증하면 충분하다는 것이다. 전역적 ID 생성기에 비해 구현하기 쉬운 접근법이다.

# 상세 설계

서비스 탐색(service discovery), 메시지 전달 흐름, 사용자 접속 상태 표시하는 방법정도를 자세히 살펴볼만한 부분이다.

## 서비스 탐색

클라이언트에게 적합한 채팅 서버를 추천하는 역할

![image](https://github.com/Learning-Is-Vital-In-Development/23-7-SystemDesignInterview/assets/61923768/63b9f989-1440-4e34-89d6-427b02a2875f)

이때 사용되는 기준은 클라이언트의 위치(geographical location), 서버 용량(capacity) 등이 있다. 널리 쓰이는 오픈 소스 솔루션은 아파치 주키퍼(Apache Zookeeper) 같은 것이 있다. 모든 채팅 서버를 등록 시켜 두고 클라이언트가 접속을 시도하면 사전에 정한 기준에 따라 최적의 채팅 서버를 골라주면 된다.

동작 과정

1. 사용자 A가 시스템에 로그인을 시도 한다.
2. 로드밸런서가 로그인 요청을 API 서버들 가운데 하나로 보낸다.
3. API 서버가 사용자 인증을 처리하고 나면 서비스 탐색 기능이 동작하여 해당 사용자를 서비스할 최적의 채팅 서버를 찾는다.
4. 사용자는 최적의 채팅 서버와 웹소켓 연결을 맺는다.

## 메세지 흐름

### 1:1 채팅 메세지 처리 흐름

![image](https://github.com/Learning-Is-Vital-In-Development/23-7-SystemDesignInterview/assets/61923768/c42fc7e3-0b4d-4042-8e46-3c043f959624)

1. 사용자 A가 채팅 서버 1로 메세지 전송
2. 채팅 서버 1은 ID 생성기를 사용해 해당 메세지의 ID 결정
3. 채팅 서버 1은 해당 메세지를 메세지 동기화 큐로 전송
4. 메세지가 키-값 저장소에 보관됨
5. (a) 사용자 B가 접속 중인 경우 메세지는 사용자 B가 접속 중인 채팅 서버로 전송
   (b) 사용자 B가 접속 중이 아닌 경우라면 푸시 알림 메시지를 푸시 알림 서버로 보냄
6. 채팅 서버 2는 메세지를 사용자 B에게 전송. 사용자 B와 채팅 서버 2 사이에는 웹 소켓 연결이 있는 상태이므로 그것을 이용

### 여러 단말 사이의 메세지 동기화

![image](https://github.com/Learning-Is-Vital-In-Development/23-7-SystemDesignInterview/assets/61923768/5d82ab64-ca2b-47e6-b56a-159b9cc60288)

사용자 A는 전화기와 랩톱의 두 대 단말을 이용하고 있다. 사용자 A가 전화기에서 채팅 앱에서 로그인한 결과로 채팅 서버 1과 해당 단말 사이에 웹소켓 연결이 만들어져 있고, 랩톱에서 로그인한 결과로 역시 별도 웹 소켓이 채팅 서버 1에 연결되어 있는 상황이다.

각 단말은 `cur_max_message_id`라는 변수를 유지하는 데, 해당 단말에서 관측된 가장 최신 메세지의 id를 추적하는 용도다. 아래 두 조건을 만족하는 메세지는 새 메세지로 간주한다.

- 수신자 ID가 현재 로그인한 사용자 ID와 같다.
- 키-값 저장소에 보관된 메세지로서, 그 ID가 `cur_max_message_id` 보다 크다.

### 소규모 그룹 채팅에서의 메세지 흐름

1:1 채팅에 비해 그룹 채팅에서의 메세지 흐름은 조금 더 복잡하다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-7-SystemDesignInterview/assets/61923768/458b2a12-4ec0-4108-a125-646e3a8eb4f9)


사용자 A가 그룹 채팅 방에서 메세지를 보냈을 때 어떤 일이 벌어지는 지 보여준다. 사용자 그룹에 3명의 사용자가 있다고 하면, A가 보낸 메세지가 사용자 B와 C의 메세지 동기화 큐에 복사된다. 이 설계는 소규모 채팅에 적합한데, 이유는 다음과 같다.

- 새로운 메세지가 왔는 지 확인하려면 자기 큐만 보면 되니까 메세지 동기화 플로가 단순하다.
- 그룹이 크지 않으면 메세지를 수신자별로 복사해서 큐에 넣는 작업의 비용이 문제가 되지 않는 다.

ref article
- [실시간 댓글 개발기(part.1) - DAU 60만 Alex 댓글의 실시간 댓글을 위한 이벤트 기반 아키텍처](https://tech.kakao.com/2020/06/08/websocket-part1/)

- [Real-time Messaging - Slack Engineering](https://slack.engineering/real-time-messaging/)

- [소개 - 슬랙이 수백만 메시지를 실시간으로 보내는 방법 (슬랙 메시징 구조)](https://youtu.be/36F35JZXFKo)
