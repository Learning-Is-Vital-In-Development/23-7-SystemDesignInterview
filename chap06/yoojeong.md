## 6장: 키-값 저장소 설계

- 키 값 데이터베이스라고도 불리는 비 관계형 데이터베이스
- 키 값은 고유 식별자여야 하며, 짧을수록 좋기 때문에 해시값을 사용하기도 한다

Q. Key 설계 어떻게 하시나요? 🤔

---

```
- key-value의 크기는 10kb 이하
- 큰 데이터 저장 가능
- HA, 장애 상황에도 빨리 응답해야함
- autoscaling
- 데이터 일관성 수준은 조절 가능해야함
- latency 최소화
```

### 단일 서버 키-값 저장소

키-값 전부를 메모리에 해시 테이블로 저장으로 구현이 쉽고 빠른 속도 보장<br>
가용 메모리 크기에 따라 데이터 압축(compression) 이나 자주 쓰이지않는 데이터는 디스크에 저장하는 방법을 쓰기도 함

### 분산 키 값 저장소

키 값 쌍을 여러 서버에 분산시키기 때문에 분산 해시 테이블이라고도 불림

#### CAP 정리

- Consistency (데이터 일관성) : 어느 노드에 접속하더라도 동일한 데이터를 제공
- Availability (데이터 가용성) : 일부 노드에 장애가 발생하더라도 데이터를 제공
- Partition Tolerance (파티션 감내) : 노드간 네트워크 단절이 있더라도 데이터를 제공

<img width="536" alt="image" src="https://user-images.githubusercontent.com/75432228/235414575-6702d56c-010c-44ce-bd96-3013a643a389.png">


현실세계 분산시스템

- CP 시스템 : 데이터 가용성을 포기 (일관성을 강조한다. 가장 보편적인 시스템 - RDB)
- AP 시스템 : 데이터 일관성을 포기 (가용성을 강조한다. 일부 테이터가 유실되더라도 서비스 가능 - NoSQL)
- CA 시스템 : 네트워크 장애(P)는 피할 수 없는 문제로 여겨져 항상 Partition Tolerance를 지원하도록 설계되어야 함 (현실세계에서는 존재하지 않는다)

### 시스템 컴포넌트

#### 데이터 파티션(partition)

데이터를 파티션 단위로 나눌때는 다음 요소를 고려해야한다.

- 데이터를 여러 서버에 고르게 분산할 수 있는가
- 노드를 추가 하거나 삭제할 때 데이터의 이동을 최소화할 수 있는가

안정 해시(consistent hash)는 이런 문제를 푸는 적합한 기술이다.

오토스케일링과 다양성을 유지할 수 있다

> 근데 안정해시가 아니라도 오토스케일링은 되지 않나?<br>
오토스케일링을 적용할 수 있다기보다는 오토스케일링 적용 시에 재배치 문제를 쉽게 해결하는 것인듯

#### 데이터 다중화(replication)

높은 가용성을 위해 데이터를 N개 서버에 비동기적으로 다중화하여 저장한다.

키를 해시 링 위에 배치하고 시계 방향으로 링을 순회하여 만나는 첫 N개 서버에 데이터 사본을 보관한다.

<img width="542" alt="image" src="https://user-images.githubusercontent.com/75432228/235414646-62aa9e81-667d-47ed-8635-638718fc386f.png">

```
N=3
s0 (key0)-> s1 -> s2 -> s3 --> ...
```

이 방법은 총 필요한 실제 물리서버가 부족할 수 있으므로 물리서버를 중복해서 선택하지 않도록 해야한다.

#### 데이터 일관성(consistency)

다중화된 노드의 데이터를 동기화를 위해 정족수 합의(Quorum Consensus) 프로토콜을 사용한다.

이 프로토콜은 3가지 값이 필요하다.

- N : 데이터 노드 수
- W : 쓰기 연산에 대한 정족수, W개 이상의 서버로부터 쓰기가 성공했다는 응답을 받아야함
- R : 읽기 연산에 대한 정족수, R개 이상의 서버로부터 읽기가 성공했다는 응답을 받아야함

```
W=N, R=1 : 읽기 연산에 최적화
W=1, R=N : 쓰기 연산에 최적화
W+R > N : 강한 일관성이 보장됨, 최소 하나의 서버는 최신 데이터를 보장
```

`일관성 모델`

|||
|:--:|:--|
|강한 일관성|- 모든 사본에 현재 쓰기 연산의 결과가 반영될 때까지 해당 데이터의 대한 **읽기/쓰기를 금지**<br>- 모든 읽기 연산은 가장 **최근에 갱신된 결과**를 반환<br>- 클라이언트는 절대로 낡은 데이터를 보지 못한다.<br>- 고가용성 시스템에는 적합하지 않음|
|약한 일관성|- 모든 노드에 현재 쓰기 연산의 결과가 일부 반영되었다면, 해당 데이터에 대한 **쓰기/읽기가 가능**한 모델<br>- 클라이언트는 가장 최근에 **갱신된 결과를 반환하지 못할 수 있다.**<br>- **고가용성**이 요구되는 시스템에 적합<br>|
|최종 일관성|- 약한 일관성의 한 형태<br>- 최종적으로 갱신 결과가 **결국에는 모든 사본에 동기화**되는 모델<br>- 다이나모 또는 카산드라는 해당 모델을 택하고 있음<br>- 클라이언트가 최신으로 **갱신된 결과를 받지 못할 수도 있는데**, 이러한 경우 클라이언트 단에서 해결 함<br>- **클라이언트 측에서 데이터의 버전 정보를 활용**해 일관성이 깨진 데이터를 읽지 않도록 해야 함<br>|

`비일관성 해소기법 (inconsistency resolution)`


#### 장애 처리

`장애감지`

두 대 이상의 서버가 특정 서버의 장애를 보고하면 장애로 간주

| 종류 | Centralized                                                                                                             | Spanning Tree                                                                                                                                                                                                                                                | Gossip                                                                                                                                                                                                |
| :--: | :---------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| | ![image](https://user-images.githubusercontent.com/75432228/235421688-d31651f0-0660-4a5a-b12b-ac9056e3feb4.png)|![image](https://user-images.githubusercontent.com/75432228/235421706-103a3fe9-27fe-4ed5-b299-11e9aa245b22.png)|![image](https://user-images.githubusercontent.com/75432228/235421727-f9c9ba0d-6b93-45e5-a2a5-e924c7621e5c.png)|
| 구현 | 하나의 중앙 컨트롤러(Central Controller)가 모든 Multicast 그룹의 멤버들을 관리하고 모든 메시지를 중앙에서 분배          | Spanning Tree 프로토콜을 사용하여 Multicast 그룹에 속한 모든 노드들을 트리 구조로 연결                                                                                                                                                                       | 각 노드가 주기적으로 메시지를 무작위로 선택한 다른 노드들에게 전파                                                                                                                                    |
| 장점 | 구현이 쉽다                                                                                                             | 각 노드들은 O(1)만큼의 과부하를 받고 각 노드들은 O(log(N))의 Latency를 보장할 수 있다                                                                                                                                                                        | 약 Log(N)의 시간안에 (낮은 Latency) 거의 대부분의 노드들에게 데이터가 전송되며 (1 - 1 / (N ^ (cb - 2)) 노드들은 약 Log(N)의 Load만을 받게 된다. 이 모든 특성을 UDP로만 이룰 수 있기때문에 더욱 효율적 |
| 단점 | Central노드가 Fail할 시 모든 노드들이 데이터를 받지 못하며 다른 모든 노드와 통신을 하기 때문에 O(N)의 Load를 받게 된다. | 한 노드에 장애가 생기면 하위 노드들이 데이터를 받지 못한다.<br> 이를 극복하기 위해 RTMP(Reliable Multicast Transport Protocol)에서는 데이터를 성공적으로 받았을때 Ack보내는 방법을 사용하지만, O(N)의 Ack Load를 Root노드에 부과하기 때문에 강점이 사라진다. | 각 노드가 메시지를 전달하는 주기를 적절히 설정해야 한다.                                                                                                                                              |

`일시적 장애 처리`

- 엄격한 정족수 접근법 : 읽기와 쓰기 금지
- 느슨한 정족수 접근법 : 장애 서버를 제외하고 다시 W,R개의 서버를 고름

장애 서버 복구까지 다른 서버가 처리하고, 복구 완료 시 남겨둔 힌트로 일괄 반영하는 것을 `hinted handoff` 라고 함

`영구적 장애 처리`

- anti-entropy protocol : 각 서버는 무작위로 선택된 다른 서버와 일정 시간마다 정보를 교환하며, 이 정보를 기반으로 사본 간의 일관성이 망가진 상태를 탐지해 문제가 발생한 서버를 식별한다.전송 데이터의 양을 줄이기 위해서는 머클 트리를 사용한다.
- 머클 트리: 데이터를 작은 블록으로 나누고, 각 블록에 대한 해시 값을 계산하여 블록들을 트리 구조로 조합. 최상단에 루트 해시 값이 있으며, 루트 해시 값은 모든 블록의 해시 값에 의해 결정하므로 데이터 변조 여부를 빠르게 확인 가능

<img width="680" alt="image" src="https://user-images.githubusercontent.com/75432228/235420176-bff11b15-8b9f-4ad3-9986-6efb4268c3aa.png">


[뱅크샐러드의 머클 트리](https://www.banksalad.com/contents/%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85%ED%95%98%EB%8A%94-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC-Merkle-Trees-%EB%9E%80-ilULl)

`데이터센터 장애`

같은 센터 내의 데이터는 장애를 동시에 겪을 가능성이 있으므로 데이터센터별로 다중화하는 것이 좋다

#### 시스템 아키텍쳐

<img width="668" alt="image" src="https://user-images.githubusercontent.com/75432228/235415270-83908a80-91ab-4438-91e2-1d139cb274f0.png">

<img width="866" alt="image" src="https://user-images.githubusercontent.com/75432228/235415318-57abd457-161e-4126-a108-7dc754c9642e.png">


#### 쓰기 경로(write path)

<img width="712" alt="image" src="https://user-images.githubusercontent.com/75432228/235418680-c212fcff-c5ee-47f6-b0c2-93d822ec46eb.png">

1. 제일 먼저 쓰기 요청이 **커밋 로그 파일(디스크)**에 기록된다.
2. 데이터가 **메모리 캐시**에 기록된다.
3. 메모리 캐시가 가득차거나 사전에 정의된 어떤 임계치에 도달하면 **데이터는 SSTable(디스크)에 기록**된다.

> SSTable<br>
Sorted-String Table의 약어로, 키-값의 순서쌍을 정렬된 리스트 형태로 관리하는 테이블


#### 읽기 경로(read path)

`데이터가 메모리에 있을 경우`

<img width="719" alt="image" src="https://user-images.githubusercontent.com/75432228/235418857-d21d7bb8-5df6-49ab-a7a1-838d96e6da1d.png">

1. 먼저 데이터가 메모리 캐시에 있는지 검사
2. 해당 데이터를 바로 클라이언트에게 반환

`데이터가 메모리에 없을 경우`

<img width="678" alt="image" src="https://user-images.githubusercontent.com/75432228/235418939-0f028d85-a93b-4506-aba7-31dd7f112b1f.png">

1. 데이터가 메모리에 있는지 검사        
2. 데이터가 메모리에 없으므로 블룸 필터를 검사
3. 블룸 필터를 통해 어떤 SSTable에 키가 보관되어 있는지 알아낸다.
4. SSTable에서 데이터를 가져온다.
5. 해당 데이터를 클라이언트에게 반환
        
> [블룸 필터](https://velog.io/@chlvlftn22/%EB%B8%94%EB%A3%B8%ED%95%84%ED%84%B0)<br>
특정 원소가 집합에 속하는지 검사하는데 사용할 수 있는 확률형 자료 구조

---

|            목표 / 문제            | 기술                                       |
| :-------------------------------: | :----------------------------------------- |
|        대규모 데이터 저장         | 안정 해시를 사용해 서버들에 부하 분산      |
| 읽기 연산에 대한 높은 가용성 보장 | 데이터를 여러 데이터센터에 다중화          |
| 쓰기 연산에 대한 높은 가용성 보장 | 버저닝 및 벡터 시계를 사용한 충돌 해소     |
|           데이터 파티션           | 안정 해시                                  |
|        점진적 규모 확장성         | 안정 해시                                  |
|              다양성               | 안정 해시                                  |
|     조절 가능한 데이터 일관성     | 정족수 합의                                |
|         일시적 장애 처리          | 느슨한 정족수 프로토콜과 단서 후 임시 위탁 |
|         영구적 장애 처리          | 머클 트리                                  |
|       데이터 센터 장애 대응       | 여러 데이터 센터에 걸친 데이터 다중화      |
